<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Arena BR</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            color: #fff;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }
        h1 { color: #0f0; margin-bottom: 10px; text-shadow: 0 0 10px #0f0; }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .stat {
            background: #111;
            padding: 8px 16px;
            border: 1px solid #333;
            border-radius: 4px;
        }
        .stat label { color: #666; font-size: 12px; }
        .stat value { color: #0f0; font-size: 18px; font-weight: bold; display: block; }
        button {
            background: #1a1a1a;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover { background: #0f0; color: #000; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #gameCanvas {
            border: 2px solid #333;
            background: #050505;
            image-rendering: pixelated;
        }
        .legend {
            margin-top: 10px;
            display: flex;
            gap: 20px;
            font-size: 12px;
            color: #666;
        }
        .legend span { display: flex; align-items: center; gap: 5px; }
        .dot { width: 10px; height: 10px; display: inline-block; }
        .bot-dot { background: #0ff; }
        .food-dot { background: #f0f; border-radius: 50%; }
        .dead-dot { background: #333; }
        
        #log {
            margin-top: 10px;
            width: 800px;
            max-width: 100%;
            height: 150px;
            background: #111;
            border: 1px solid #333;
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
        }
        #log .entry { margin: 2px 0; }
        #log .kill { color: #f00; }
        #log .food { color: #f0f; }
        #log .spawn { color: #0ff; }
    </style>
</head>
<body>
    <h1>üêç SNAKE ARENA BR - SIMULATION</h1>
    
    <div class="controls">
        <div class="stat">
            <label>TICK</label>
            <value id="tickDisplay">0</value>
        </div>
        <div class="stat">
            <label>ALIVE</label>
            <value id="aliveDisplay">0</value>
        </div>
        <div class="stat">
            <label>FOOD</label>
            <value id="foodDisplay">0</value>
        </div>
        <div class="stat">
            <label>BOT RATE</label>
            <div style="display: flex; align-items: center; gap: 4px;">
                <input type="number" id="moveRateInput" value="3" min="1" max="100" style="width: 40px; background: #222; border: 1px solid #333; color: #0f0; padding: 4px;">
                <span style="font-size: 11px; color: #666;">/ 20s</span>
            </div>
        </div>
        <div class="stat">
            <label>
                <input type="checkbox" id="rateLimitCheck" checked style="margin-right: 4px;">
                RATE LIMIT
            </label>
        </div>
        <button id="startBtn">START</button>
        <button id="pauseBtn" disabled>PAUSE</button>
        <button id="resetBtn">RESET</button>
        <div style="font-size: 12px; color: #666;">
            100 bots ‚Ä¢ Watch them fight
        </div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    
    <div class="legend">
        <span><span class="dot bot-dot"></span> Bots</span>
        <span><span class="dot food-dot"></span> Food</span>
        <span><span class="dot dead-dot"></span> Dead</span>
    </div>
    
    <div id="log"></div>

    <script>
        // ============================================
        // CONSTANTS - Same constraints as on-chain
        // ============================================
        const GRID_SIZE = 200;        // 200x200 grid
        const CANVAS_SIZE = 800;      // Render size
        const CELL_SIZE = CANVAS_SIZE / GRID_SIZE; // 4px per cell
        const TICK_RATE_MS = 100;     // 10 ticks per second
        const MOVE_WINDOW_MS = 20000; // 20 second window (configurable rate)
        const INITIAL_FOOD = 500;     // Fixed food count at game start
        const MAX_BOTS = 100;         // 100 bots (no player - simulation mode)
        const INITIAL_LENGTH = 5;
        
        // ============================================
        // GAME STATE
        // ============================================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.tickCount = 0;
                this.running = false;
                this.snakes = new Map();
                this.food = new Set();
                this.lastTickTime = 0;
                this.moveQueue = new Map(); // Pending moves for next tick
                this.moveLimit = 3; // Configurable moves per window
            }
            
            getMoveLimit() {
                const input = document.getElementById('moveRateInput');
                return parseInt(input?.value || '3', 10);
            }
            
            log(msg, type = '') {
                const logEl = document.getElementById('log');
                const entry = document.createElement('div');
                entry.className = `entry ${type}`;
                entry.textContent = `[T${this.tickCount}] ${msg}`;
                logEl.appendChild(entry);
                logEl.scrollTop = logEl.scrollHeight;
                if (logEl.children.length > 100) {
                    logEl.removeChild(logEl.firstChild);
                }
            }
            
            init() {
                this.snakes.clear();
                this.food.clear();
                this.moveQueue.clear();
                this.tickCount = 0;
                
                // Spawn bots only (no player - simulation mode)
                for (let i = 0; i < MAX_BOTS; i++) {
                    this.spawnSnake(`bot_${i}`);
                }
                
                // Initial food - fixed for entire game
                for (let i = 0; i < INITIAL_FOOD; i++) {
                    this.spawnFood();
                }
                
                this.updateUI();
            }
            
            spawnSnake(id) {
                let attempts = 0;
                let x, y, dir;
                
                // Find empty spot with room for entire body
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                    dir = Math.floor(Math.random() * 4);
                    
                    // Check if entire snake fits within bounds
                    let dx = 0, dy = 0;
                    switch (dir) {
                        case 0: dy = 1; break; // facing up, body extends down
                        case 1: dx = -1; break; // facing right, body extends left
                        case 2: dy = -1; break; // facing down, body extends up
                        case 3: dx = 1; break; // facing left, body extends right
                    }
                    
                    let fits = true;
                    for (let i = 0; i < INITIAL_LENGTH; i++) {
                        const bx = x + dx * i;
                        const by = y + dy * i;
                        if (bx < 0 || bx >= GRID_SIZE || by < 0 || by >= GRID_SIZE) {
                            fits = false;
                            break;
                        }
                    }
                    
                    attempts++;
                } while ((!fits || this.isOccupied(x, y)) && attempts < 100);
                
                if (attempts >= 100) return false;
                
                const snake = {
                    id,
                    body: [],
                    alive: true,
                    direction: dir,
                    lastMoveTime: 0,
                    movesThisWindow: 0,
                    windowStart: Date.now(),
                    color: this.getBotColor(id)
                };
                
                // Build initial body extending opposite to facing direction
                let dx = 0, dy = 0;
                switch (snake.direction) {
                    case 0: dy = 1; break; // facing up, body extends down
                    case 1: dx = -1; break; // facing right, body extends left
                    case 2: dy = -1; break; // facing down, body extends up
                    case 3: dx = 1; break; // facing left, body extends right
                }
                for (let i = 0; i < INITIAL_LENGTH; i++) {
                    snake.body.push({
                        x: x + dx * i,
                        y: y + dy * i
                    });
                }
                
                this.snakes.set(id, snake);
                return true;
            }
            
            getBotColor(id) {
                const hue = (parseInt(id.split('_')[1]) * 137.5) % 360;
                return `hsl(${hue}, 70%, 50%)`;
            }
            
            spawnFood() {
                let attempts = 0;
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                    attempts++;
                } while (this.isOccupied(x, y) && attempts < 100);
                
                if (attempts < 100) {
                    this.food.add(`${x},${y}`);
                }
            }
            
            isOccupied(x, y) {
                // Check snakes
                for (const snake of this.snakes.values()) {
                    if (!snake.alive) continue;
                    for (const seg of snake.body) {
                        if (seg.x === x && seg.y === y) return true;
                    }
                }
                // Check food
                if (this.food.has(`${x},${y}`)) return true;
                return false;
            }
            
            isRateLimitEnabled() {
                return document.getElementById('rateLimitCheck')?.checked ?? true;
            }
            
            canMove(snake) {
                // Realtime mode - no limit
                if (!this.isRateLimitEnabled()) return true;
                
                const now = Date.now();
                const limit = this.getMoveLimit();
                
                // Reset window if expired
                if (now - snake.windowStart >= MOVE_WINDOW_MS) {
                    snake.windowStart = now;
                    snake.movesThisWindow = 0;
                }
                
                return snake.movesThisWindow < limit;
            }
            
            queueMove(snakeId, direction) {
                const snake = this.snakes.get(snakeId);
                if (!snake || !snake.alive) return false;
                if (!this.canMove(snake)) return false;
                
                // Prevent 180-degree turns (skip for first move)
                const opposite = (direction + 2) % 4;
                if (snake.lastMoveTime > 0 && snake.direction === opposite && snake.body.length > 1) {
                    return false;
                }
                
                this.moveQueue.set(snakeId, direction);
                return true;
            }
            
            tick() {
                this.tickCount++;
                
                // Process bot moves (AI) for all snakes
                for (const snake of this.snakes.values()) {
                    if (!snake.alive) continue;
                    if (this.canMove(snake)) {
                        const move = this.getBotMove(snake);
                        if (move !== null) {
                            this.queueMove(snake.id, move);
                        }
                    }
                }
                
                // Process all queued moves
                const moves = Array.from(this.moveQueue.entries());
                this.moveQueue.clear();
                
                // Track next positions for collision detection
                const nextPositions = new Map();
                const deadSnakes = new Set();
                
                for (const [id, direction] of moves) {
                    const snake = this.snakes.get(id);
                    if (!snake || !snake.alive) continue;
                    
                    snake.direction = direction;
                    snake.movesThisWindow++;
                    snake.lastMoveTime = Date.now();
                    
                    const head = snake.body[0];
                    let nx = head.x;
                    let ny = head.y;
                    
                    switch (direction) {
                        case 0: ny = ny - 1; break; // up
                        case 1: nx = nx + 1; break; // right
                        case 2: ny = ny + 1; break; // down
                        case 3: nx = nx - 1; break; // left
                    }
                    
                    // Check wall collision
                    if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) {
                        deadSnakes.add(id);
                        continue;
                    }
                    
                    nextPositions.set(id, {x: nx, y: ny, snake});
                }
                
                // Track fractured snakes (body index where cut happens)
                const fracturedSnakes = new Map(); // snakeId -> body index to keep (tail is removed)
                
                // Phase 1: Check head-on collisions (longer snake wins)
                const headOnLosers = new Set();
                for (const [id, next] of nextPositions) {
                    if (headOnLosers.has(id)) continue;
                    
                    for (const [otherId, otherNext] of nextPositions) {
                        if (otherId <= id || headOnLosers.has(otherId)) continue; // Avoid double check
                        
                        if (next.x === otherNext.x && next.y === otherNext.y) {
                            // Head-on collision! Longer snake wins
                            const snake = next.snake;
                            const otherSnake = otherNext.snake;
                            
                            if (snake.body.length > otherSnake.body.length) {
                                headOnLosers.add(otherId);
                                this.log(`${id} CRUSHED ${otherId} (${snake.body.length} vs ${otherSnake.body.length})`, 'kill');
                            } else if (otherSnake.body.length > snake.body.length) {
                                headOnLosers.add(id);
                                this.log(`${otherId} CRUSHED ${id} (${otherSnake.body.length} vs ${snake.body.length})`, 'kill');
                            } else {
                                // Equal length = both die
                                headOnLosers.add(id);
                                headOnLosers.add(otherId);
                                this.log(`${id} and ${otherId} TIED and DIED`, 'kill');
                            }
                        }
                    }
                }
                
                // Phase 2: Check body collisions (attacker fractures defender)
                for (const [id, next] of nextPositions) {
                    if (headOnLosers.has(id)) continue; // Already dead
                    const {x, y, snake} = next;
                    
                    // Check self collision first
                    for (let i = 0; i < snake.body.length - 1; i++) {
                        if (snake.body[i].x === x && snake.body[i].y === y) {
                            deadSnakes.add(id);
                            break;
                        }
                    }
                    if (deadSnakes.has(id)) continue;
                    
                    // Check hitting other snake's body
                    for (const [otherId, otherSnake] of this.snakes) {
                        if (otherId === id || !otherSnake.alive) continue;
                        if (headOnLosers.has(otherId)) continue; // They're already dead
                        
                        for (let i = 0; i < otherSnake.body.length; i++) {
                            const seg = otherSnake.body[i];
                            if (seg.x === x && seg.y === y) {
                                if (i === 0) {
                                    // Hit their head - this is handled by head-on (shouldn't happen here)
                                    // But if it does, both die
                                    deadSnakes.add(id);
                                    headOnLosers.add(otherId);
                                } else {
                                    // Hit their body - fracture them at this point
                                    // Keep body[0..i], remove body[i+1..end]
                                    const oldLength = otherSnake.body.length;
                                    fracturedSnakes.set(otherId, i);
                                    this.log(`${id} CUT ${otherId} at ${i}! (${oldLength} ‚Üí ${i+1})`, 'kill');
                                }
                                break;
                            }
                        }
                    }
                }
                
                // Apply fractures (remove tail segments)
                for (const [id, keepIndex] of fracturedSnakes) {
                    const snake = this.snakes.get(id);
                    if (snake && snake.alive) {
                        // Keep only body[0..keepIndex], truncate the rest
                        snake.body = snake.body.slice(0, keepIndex + 1);
                    }
                }
                
                // Apply deaths
                for (const id of headOnLosers) {
                    deadSnakes.add(id);
                }
                for (const id of deadSnakes) {
                    const snake = this.snakes.get(id);
                    if (snake) {
                        snake.alive = false;
                    }
                }
                
                // Move surviving snakes
                for (const [id, next] of nextPositions) {
                    if (deadSnakes.has(id)) continue;
                    
                    const snake = next.snake;
                    const {x, y} = next;
                    
                    // Check food
                    const foodKey = `${x},${y}`;
                    let grew = false;
                    if (this.food.has(foodKey)) {
                        this.food.delete(foodKey);
                        grew = true;
                    }
                    
                    // Move: add new head
                    snake.body.unshift({x, y});
                    
                    // Remove tail if didn't grow
                    if (!grew) {
                        snake.body.pop();
                    }
                }
                
                // Food is fixed - no respawning
                
                this.updateUI();
            }
            
            getBotMove(snake) {
                const head = snake.body[0];
                const directions = [0, 1, 2, 3]; // up, right, down, left
                
                // Get valid moves (no immediate death)
                const moveScores = directions.map(dir => {
                    // Prevent 180
                    const opposite = (dir + 2) % 4;
                    if (snake.direction === opposite && snake.body.length > 1) return null;
                    
                    let nx = head.x;
                    let ny = head.y;
                    switch (dir) {
                        case 0: ny = ny - 1; break;
                        case 1: nx = nx + 1; break;
                        case 2: ny = ny + 1; break;
                        case 3: nx = nx - 1; break;
                    }
                    
                    // Check wall collision - FATAL
                    if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) {
                        return null;
                    }
                    
                    // Check self collision (always fatal)
                    for (let i = 0; i < snake.body.length - 1; i++) {
                        if (snake.body[i].x === nx && snake.body[i].y === ny) return null;
                    }
                    
                    // Check other snakes - AVOID only dangerous heads
                    for (const other of this.snakes.values()) {
                        if (other.id === snake.id || !other.alive) continue;
                        
                        const otherHead = other.body[0];
                        
                        // Check if we're hitting their head
                        if (otherHead.x === nx && otherHead.y === ny) {
                            // Head-on collision! Only allow if we're strictly longer
                            if (snake.body.length <= other.body.length) {
                                return null; // We'll die or tie, avoid
                            }
                            // We're longer, so this is a valid attack - continue checking
                        }
                        
                        // Hitting their body is now VALID - it's a cut attack!
                        // We don't return null here anymore
                    }
                    
                    return { dir, nx, ny };
                }).filter(m => m !== null);
                
                if (moveScores.length === 0) return null;
                
                // Score each move
                let bestMove = moveScores[0].dir;
                let bestScore = -Infinity;
                
                for (const move of moveScores) {
                    const { dir, nx, ny } = move;
                    let score = 0;
                    
                    // 1. ATTACK: Can we kill/fracture another snake?
                    for (const other of this.snakes.values()) {
                        if (other.id === snake.id || !other.alive) continue;
                        
                        const otherHead = other.body[0];
                        const distToOtherHead = Math.abs(nx - otherHead.x) + Math.abs(ny - otherHead.y);
                        
                        // HEAD-ON: If we're longer, go for it!
                        if (distToOtherHead === 1) {
                            if (snake.body.length > other.body.length) {
                                score += 2000; // CRUSH them!
                            } else if (snake.body.length === other.body.length) {
                                score -= 500; // Tie = death, avoid
                            } else {
                                score -= 1000; // We'll die, avoid!
                            }
                        }
                        
                        // Predict their next move and try to head-on
                        if (distToOtherHead <= 2) {
                            const theirDir = other.direction;
                            let theirNextX = otherHead.x;
                            let theirNextY = otherHead.y;
                            switch (theirDir) {
                                case 0: theirNextY = theirNextY - 1; break;
                                case 1: theirNextX = theirNextX + 1; break;
                                case 2: theirNextY = theirNextY + 1; break;
                                case 3: theirNextX = theirNextX - 1; break;
                            }
                            
                            // Only intercept if they're not hitting a wall
                            if (theirNextX >= 0 && theirNextX < GRID_SIZE && 
                                theirNextY >= 0 && theirNextY < GRID_SIZE &&
                                nx === theirNextX && ny === theirNextY && 
                                snake.body.length > other.body.length) {
                                score += 1500; // Intercept and crush!
                            }
                        }
                        
                        // BODY CUT: Can we cut their body?
                        for (let i = 1; i < other.body.length; i++) { // Start at 1 to skip head
                            const seg = other.body[i];
                            if (seg.x === nx && seg.y === ny) {
                                // We're cutting them at position i!
                                const segmentsLost = other.body.length - (i + 1);
                                score += 500 + segmentsLost * 50; // Bonus for longer cuts
                            }
                            
                            // Adjacent to body = good setup position
                            const distToSeg = Math.abs(nx - seg.x) + Math.abs(ny - seg.y);
                            if (distToSeg === 1) {
                                score += 30;
                            }
                        }
                    }
                    
                    // 2. WALL AVOIDANCE: Stay away from edges
                    const distToWall = Math.min(nx, ny, GRID_SIZE - 1 - nx, GRID_SIZE - 1 - ny);
                    if (distToWall === 0) {
                        score -= 10000; // This shouldn't happen (filtered above), but just in case
                    } else if (distToWall <= 2) {
                        score -= (3 - distToWall) * 200; // Penalty for being close to walls
                    }
                    
                    // 3. SURVIVAL: Check for danger (other snake heads nearby)
                    let dangerScore = 0;
                    for (const other of this.snakes.values()) {
                        if (other.id === snake.id || !other.alive) continue;
                        const otherHead = other.body[0];
                        const dist = Math.abs(nx - otherHead.x) + Math.abs(ny - otherHead.y);
                        if (dist <= 2) {
                            dangerScore -= 100; // Avoid close encounters
                        }
                    }
                    score += dangerScore;
                    
                    // 4. FOOD: Near food is good
                    let foodScore = 0;
                    for (const foodKey of this.food) {
                        const [fx, fy] = foodKey.split(',').map(Number);
                        const dist = Math.abs(nx - fx) + Math.abs(ny - fy);
                        if (dist === 0) {
                            foodScore += 30; // Eating food
                        } else if (dist <= 5) {
                            foodScore += (6 - dist) * 3; // Nearby food
                        }
                    }
                    score += foodScore;
                    
                    // 5. SPACE: Keep some room to maneuver (no wrapping)
                    let space = 0;
                    for (let dx = -2; dx <= 2; dx++) {
                        for (let dy = -2; dy <= 2; dy++) {
                            const cx = nx + dx;
                            const cy = ny + dy;
                            // Skip if outside bounds
                            if (cx < 0 || cx >= GRID_SIZE || cy < 0 || cy >= GRID_SIZE) continue;
                            
                            let occupied = false;
                            for (const other of this.snakes.values()) {
                                if (!other.alive) continue;
                                for (const seg of other.body) {
                                    if (seg.x === cx && seg.y === cy) {
                                        occupied = true;
                                        break;
                                    }
                                }
                                if (occupied) break;
                            }
                            if (!occupied) space++;
                        }
                    }
                    score += space;
                    
                    // 5. AGGRESSION: Move toward nearest enemy head
                    let nearestEnemyDist = Infinity;
                    for (const other of this.snakes.values()) {
                        if (other.id === snake.id || !other.alive) continue;
                        const otherHead = other.body[0];
                        const dist = Math.abs(nx - otherHead.x) + Math.abs(ny - otherHead.y);
                        nearestEnemyDist = Math.min(nearestEnemyDist, dist);
                    }
                    if (nearestEnemyDist !== Infinity) {
                        score -= nearestEnemyDist * 2; // Closer to enemies = higher score
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = dir;
                    }
                }
                
                return bestMove;
            }
            
            render() {
                // Clear
                this.ctx.fillStyle = '#050505';
                this.ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                
                // Draw grid (subtle)
                this.ctx.strokeStyle = '#111';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i <= GRID_SIZE; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * CELL_SIZE, 0);
                    this.ctx.lineTo(i * CELL_SIZE, CANVAS_SIZE);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * CELL_SIZE);
                    this.ctx.lineTo(CANVAS_SIZE, i * CELL_SIZE);
                    this.ctx.stroke();
                }
                
                // Draw walls (red border)
                this.ctx.strokeStyle = '#f00';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                
                // Draw food
                this.ctx.fillStyle = '#f0f';
                for (const foodKey of this.food) {
                    const [x, y] = foodKey.split(',').map(Number);
                    this.ctx.fillRect(
                        x * CELL_SIZE,
                        y * CELL_SIZE,
                        CELL_SIZE,
                        CELL_SIZE
                    );
                }
                
                // Draw snakes
                for (const snake of this.snakes.values()) {
                    if (!snake.alive) continue;
                    
                    this.ctx.fillStyle = snake.color;
                    for (let i = 0; i < snake.body.length; i++) {
                        const seg = snake.body[i];
                        const alpha = 1 - (i / snake.body.length) * 0.5;
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillRect(
                            seg.x * CELL_SIZE,
                            seg.y * CELL_SIZE,
                            CELL_SIZE,
                            CELL_SIZE
                        );
                    }
                    this.ctx.globalAlpha = 1;
                    
                    // Draw head brighter (full cell, no alpha)
                    const head = snake.body[0];
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(
                        head.x * CELL_SIZE,
                        head.y * CELL_SIZE,
                        CELL_SIZE,
                        CELL_SIZE
                    );
                }
                
            }
            
            updateUI() {
                document.getElementById('tickDisplay').textContent = this.tickCount;
                
                const alive = Array.from(this.snakes.values()).filter(s => s.alive).length;
                document.getElementById('aliveDisplay').textContent = alive;
                document.getElementById('foodDisplay').textContent = this.food.size;
            }
            
            start() {
                if (!this.running) {
                    this.running = true;
                    this.gameLoop();
                }
            }
            
            pause() {
                this.running = false;
            }
            
            reset() {
                this.pause();
                this.init();
                this.render();
            }
            
            gameLoop() {
                if (!this.running) return;
                
                const now = performance.now();
                if (now - this.lastTickTime >= TICK_RATE_MS) {
                    this.tick();
                    this.lastTickTime = now;
                }
                
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // ============================================
        // INIT
        // ============================================
        const game = new Game();
        game.init();
        game.render();
        
        // Controls
        document.getElementById('startBtn').addEventListener('click', () => {
            game.start();
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            game.pause();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            game.reset();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        });
    </script>
</body>
</html>
